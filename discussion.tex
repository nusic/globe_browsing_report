\chapter{Discussion}
In this chapter, the resulting implementation and design decisions made through out the research phase and development phase will be discussed along with the results presented in chapter \ref{chapter:results}.

\section{Chunked LOD}
From Figure \ref{fig:topdown} and \ref{fig:interaction} it is noted that the chunk tree grows as the camera comes closer to the surface, but the number of rendered chunks remain relativelty constant.
From Figure \ref{fig:interaction} we can see that the chunk tree grows as the camera views the horizon, as do the number of rendered chunks. When turning the the camera 180 degrees, the chunk tree shrinks temporarily. This is a result of the chunk tree being limited by available data. As the new texture tiles are downloaded, the chunk tree grows accordingly.

\section{Ellipsoids vs Spheres}
Representing globes as ellipsoids and not as spheres was a decision settled early in the development process. 
The accuracy that the ellipsoidal model gives is important to be able to show near Earth orbits and rocket launches where the space crafts need to be positioned accurately relative to the WGS84 reference frame which is used in the SPICE library. 
Other globes such as the planet Saturn has a clearly visible ellipsoidal shape due to its angular momentum. This can now be shown in OpenSpace by configuring the planet to have the correct radii.

\section{Tesselation and Projection}
The choice of using geographic tessellation for the ellipsoid was a direct result of using equirectangular geodetic map projections. 
The equirectangular geodetic map projection is very common for many public map datasets and was therefore a given choice to be able to visualize a vast amount of data on the globes surfaces.

The drawbacks with oversampling at the poles giving undesired visual artefacts was considered, but in the end prioritized down due to time restrictions. However, due to the fact that the issue of polar pinching was not handled explicitly, the resulting issue of performance drops close to the poles can be seen in section \ref{section:res_polarpinching}.

The most reasonable solution to the polar issues would be to use polar caps similar to Dimitrijevi\'{c} and Ran\v{c}i\'{c}'s solution \cite{dimi15}. Even though the LOD algorithm is different, the similarities in tessellation map projection would mean that the implementation would have similar characteristics. Polar caps will however not solve all problems related to poles in geographical grid tessellations. The first time the software wants to render chunks on a polar cap near the pole, it will still need to request all the same tiles that a it would using a standard geographical grid tessellation. If it later is able to cache all reprojected tiles, they will be faster to render next time they are requested. The requests together with the re-projections will make it slower to visualize tiles at the caps, this could be a big limitation for datasets that needs to be accessed fast such as temporal datasets used for animating textures. Many of the GIBS datasets however are available in both equirectangular format as well as polar stereographic (EPSG:3413) for the North Pole and antarctic polar stereographic (EPSG:3031) for the South Pole. Hence re-projection would not be needed if the polar caps are defined with stereographic projections. 

\section{Chunked LOD vs Ellipsoidal Clipmaps}
Both Ellipsoidal clipmaps and chunked LOD were thoroghly considered as the overall LOD algorithm to used. Both methods were implemented as proofs of concepts before deciding on using the chunked LOD approach.

The clipmap implementation was aborted as the chunked LOD was significantly more straight forward to implement and early on started yielding visible results. Moreover, having decided on using equirectangular tessellation and map projection, the ellipsoidal clipmap approach would completely depend on an working implementation of polar caps, which would have extended the implementation time further with the need of considering both re-projection and edges.

Even though geometry clipmaps would pose some very different rendering challenges than the chunked LOD approach, many components developed for the chunked LOD approach could be shared between the two approaches.
The commonly used components would include the entire texture data pipeline and layer structure along with all the geometric related calculations, the interaction mode and various helper classes. The main difference is the rendering pipeline even though it also has similarities; for example, using the model space and camera space vertex rendering schemes could be done for geometry clipmaps just as well as for chunk grids.

\section{Mip Level Blending}
All the chunk tiles represent the same geodetic area at different mip level. 
The texture data within a single dataset does not have to be strictly down sampled versions of the original size. 
The dataset may be combined from multiple different data sources such as satellite imagery and aerial photographs. 
Thus, two adjacent mip levels within a map dataset may look very different from one another. 
One such example is the ESRI Imagery World 2D true color map over Naturpark Karwendel near Innsbruck, Austria; the dataset has a drastic transition between two mip levels where the mountains of the Alps have been photographed both with and without snow coverage.

As seen in the results of section \ref{section:res_switching}, the level blending removes the otherwise visible edges between chunks of different level. However, worth noticing from the results is also the fact that the blended textures have lower overall resolution than the original tiles using no blending. In other words, blending must be considered as a weighting between lower texture resolution and potential popping artifacts and visible edges. 

\section{Parallel Tile Requests}
\label{section:parallelrequests}
Requesting tiles from a given remote dataset could in theory be performed in parallel but GDAL puts some restrictions on open datasets. GDAL can internally request tiles in parallel when performing the RasterIO operation. However, GDAL does not guarantee thread safe reading within all its formats. Reading from one open dataset on several threads in parallel often results in corrupt tiles. If the parallelization is limited to be performed on separate overviews however, GDAL's data writing and caching would hopefully not lead to race conditions between threads since overviews are completely separated from each other. Another method to speed up GDAL requests could be to open several GDAL dataset per tile dataset. However this will lead to internal cache misses within GDAL that most likely results in even slower requests and unnecessary memory usage.

\section{High Resolution Local Patches}
The software was implemented to be able to handle highly detailed datasets down to 25 centimeters per pixel as shown in section \ref{section:localpatchesresult} rendering HiRISE patches. Using the combination of HiRISE patches, CTX patches, and a global terrain model with textures, the detail level together with the vast scale of surrounding canyon walls resulted in a combined view as close as possible to the real landscapes of Mars.

As described under Appendix \ref{appendix:localpatches} however, reading local patches used to render in OpenSpace requires extensive amount of preprocessing. Another issue is that a very sparse dataset specified with a virtual dataset (described in Appendix \ref{appendix:localpatches}) currently poses on OpenSpace is that empty tiles outside of the defined region are still initialized which makes the software run slower. The preprocessing and the unnecessary initialization makes reading and rendering of local patches more of a proof of concept and will be left for further development as future work.